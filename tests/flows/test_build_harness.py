from pathlib import Path

import pytest
from filare.flows.build_harness import (
    _build_metadata,
    _collect_templates,
    _normalize_connection_set,
    build_harness_from_files,
)
from filare.models.types import AUTOGENERATED_PREFIX
from filare.errors import (
    ComponentTypeMismatch,
    ConnectionCountMismatchError,
    MissingConnectionCountError,
    MissingOutputSpecification,
    MultipleSeparatorError,
    RedefinedDesignatorError,
    UnknownTemplateDesignator,
)


@pytest.fixture
def extra_metadata(tmp_path):
    return {
        "output_dir": tmp_path,
        "output_names": [],
        "titlepage": tmp_path / "titlepage",
        "sheet_total": 1,
        "sheet_current": 1,
        "sheet_name": "S",
        "files": [],
        "use_qty_multipliers": False,
        "multiplier_file_name": "qty.txt",
        "authors": {},
        "revisions": {},
    }


@pytest.mark.functional
def test_build_harness_happy_path(tmp_path, extra_metadata):
    harness = tmp_path / "h.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
connectors:
  X1:
    pincount: 2
  X2:
    pincount: 2
cables:
  C1:
    wirecount: 2
connections:
  -
    - X1: [1,2]
    - C1: [1,2]
    - X2: [1,2]
"""
    )
    meta.write_text(
        """\
metadata:
  title: test
  pn: PN-1
  company: Test Co
  address: 123
"""
    )
    ret = build_harness_from_files(
        inp=[harness],
        metadata_files=[meta],
        return_types=("harness",),
        output_formats=(),
        output_dir=tmp_path,
        extra_metadata=extra_metadata,
    )
    harness_model = ret["harness"]
    assert harness_model.connectors["X1"].pincount == 2
    assert harness_model.cables["C1"].wirecount == 2
    assert harness_model.shared_bom


def test_build_harness_rejects_mismatched_connection_counts(tmp_path, extra_metadata):
    harness = tmp_path / "h_bad.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
connectors:
  X1:
    pincount: 2
cables:
  C1:
    wirecount: 2
connections:
  -
    - X1: [1]
    - C1: [1,2]
"""
    )
    meta.write_text("metadata: {title: test, pn: PN-1, company: Test, address: 123}")
    with pytest.raises(ConnectionCountMismatchError) as exc:
        build_harness_from_files(
            inp=[harness],
            metadata_files=[meta],
            return_types=("harness",),
            output_formats=(),
            output_dir=tmp_path,
            extra_metadata=extra_metadata,
        )
    assert "number of connections" in str(exc.value).lower()


def test_build_harness_requires_output_format_or_return(tmp_path, extra_metadata):
    meta = tmp_path / "meta.yml"
    harness = tmp_path / "h.yml"
    meta.write_text("metadata: {title: test, pn: PN-1, company: Test, address: 123}")
    harness.write_text("connections: []")
    with pytest.raises(MissingOutputSpecification):
        build_harness_from_files(
            inp=[harness],
            metadata_files=[meta],
            return_types=None,
            output_formats=None,
            output_dir=tmp_path,
            extra_metadata=extra_metadata,
        )


def test_build_harness_enforces_alternating_types(tmp_path, extra_metadata):
    harness = tmp_path / "h_bad_alt.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
connectors:
  X1: {pincount: 1}
  X2: {pincount: 1}
connections:
  -
    - X1: [1]
    - X2: [1]
"""
    )
    meta.write_text("metadata: {title: test, pn: PN-1, company: Test, address: 123}")
    with pytest.raises(ComponentTypeMismatch) as exc:
        build_harness_from_files(
            inp=[harness],
            metadata_files=[meta],
            return_types=("harness",),
            output_formats=(),
            output_dir=tmp_path,
            extra_metadata=extra_metadata,
        )
    assert "expected" in str(exc.value).lower()


@pytest.mark.functional
def test_build_harness_overview_sets_styles(tmp_path, extra_metadata):
    harness = tmp_path / "h_overview.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
connectors:
  X1: {pincount: 1}
  X2: {pincount: 1}
cables:
  C1: {wirecount: 1}
connections:
  -
    - X1: [1]
    - C1: [1]
    - X2: [1]
"""
    )
    meta.write_text("metadata: {title: test, pn: PN-1, company: Test, address: 123}")
    ret = build_harness_from_files(
        inp=[harness],
        metadata_files=[meta],
        return_types=("harness",),
        output_formats=(),
        output_dir=tmp_path,
        extra_metadata=extra_metadata,
        connector_view="overview",
    )
    h_model = ret["harness"]
    assert all(c.style == "overview" for c in h_model.connectors.values())
    assert all(cable.style == "overview" for cable in h_model.cables.values())


def test_build_harness_additional_bom_items(tmp_path, extra_metadata):
    harness = tmp_path / "h_add.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text("additional_bom_items:\n  - {type: Tape}\nconnections: []\n")
    meta.write_text("metadata: {title: test, pn: PN-1, company: Test, address: 123}")
    ret = build_harness_from_files(
        inp=[harness],
        metadata_files=[meta],
        return_types=("harness",),
        output_formats=(),
        output_dir=tmp_path,
        extra_metadata=extra_metadata,
    )
    assert len(ret["harness"].additional_bom_items) == 1


def test_normalize_connection_set_autogenerated_designator():
    connection_set = [["tpl."]]
    designators = {}
    autogenerated = {}
    normalized, count = _normalize_connection_set(
        connection_set, ".", designators, autogenerated
    )
    assert count == 1
    gen_name = list(designators.keys())[0]
    assert gen_name.startswith(AUTOGENERATED_PREFIX + "tpl")
    assert normalized[0][0][gen_name] == 1


def test_normalize_connection_set_multiple_separators_raises():
    with pytest.raises(MultipleSeparatorError):
        _normalize_connection_set([["a.b.c"]], ".", {}, {})


def test_collect_templates_handles_missing_sections():
    yaml_data = {}
    connectors, cables, connections = _collect_templates(yaml_data, image_paths=set())
    assert connectors == {}
    assert cables == {}
    assert connections == []


def test_collect_templates_resolves_relative_image(tmp_path):
    img = tmp_path / "img.png"
    img.write_text("x")
    yaml_data = {
        "connectors": {"X1": {"pincount": 1, "image": {"src": img.name}}},
        "cables": {},
        "connections": [],
    }
    connectors, _, _ = _collect_templates(yaml_data, image_paths={tmp_path})
    assert Path(connectors["X1"]["image"]["src"]).is_absolute()


def test_build_metadata_merges_extra(tmp_path):
    yaml_file = tmp_path / "h.yml"
    yaml_file.write_text("connections: []")
    yaml_data = {"metadata": {"pn": "PN-BASE"}}
    extra = {
        "output_dir": tmp_path,
        "output_names": [],
        "titlepage": tmp_path,
        "sheet_total": 1,
        "sheet_current": 1,
        "sheet_name": "S",
        "files": [],
        "use_qty_multipliers": False,
        "multiplier_file_name": "qty.txt",
        "company": "ACME",
        "address": "Addr",
        "authors": {},
        "revisions": {},
    }
    meta = _build_metadata(yaml_file, yaml_data, extra, "out")
    assert meta.output_name == "out"
    assert meta.company == "ACME"


def test_normalize_connection_set_redefinition_error():
    with pytest.raises(RedefinedDesignatorError):
        _normalize_connection_set([["B.X"]], ".", {"X": "A"}, {})


def test_normalize_connection_set_valueerror_no_counts():
    with pytest.raises(MissingConnectionCountError):
        _normalize_connection_set([{"X1": []}], ".", {}, {})


def test_metadata_typeerror_branch(monkeypatch, tmp_path, extra_metadata):
    harness = tmp_path / "h.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text("connections: []")
    meta.write_text("metadata: {}")

    def boom(*args, **kwargs):
        raise TypeError("bad metadata")

    monkeypatch.setattr("filare.flows.build_harness._build_metadata", boom)
    with pytest.raises(TypeError):
        build_harness_from_files(
            inp=[harness],
            metadata_files=[meta],
            return_types=("harness",),
            output_formats=(),
            output_dir=tmp_path,
            extra_metadata=extra_metadata,
        )


def test_unknown_template_raises(tmp_path, extra_metadata):
    harness = tmp_path / "h_unknown.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
cables:
  C1: {wirecount: 1}
connections:
  -
    - UNKNOWN: [1]
    - C1: [1]
"""
    )
    meta.write_text("metadata: {title: t, pn: p, company: c, address: a}")
    with pytest.raises(UnknownTemplateDesignator):
        build_harness_from_files(
            inp=[harness],
            metadata_files=[meta],
            return_types=("harness",),
            output_formats=(),
            output_dir=tmp_path,
            extra_metadata=extra_metadata,
        )


@pytest.mark.functional
def test_cable_first_connection_hits_none_branch(tmp_path, extra_metadata):
    harness = tmp_path / "h_cable_first.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
connectors:
  X1: {pincount: 1}
cables:
  C1: {wirecount: 1}
connections:
  -
    - C1: [1]
    - X1: [1]
"""
    )
    meta.write_text("metadata: {title: t, pn: p, company: c, address: a}")
    ret = build_harness_from_files(
        inp=[harness],
        metadata_files=[meta],
        return_types=("harness",),
        output_formats=(),
        output_dir=tmp_path,
        extra_metadata=extra_metadata,
    )
    assert ret["harness"].cables["C1"]


def test_additional_bom_items_error_branch(monkeypatch, tmp_path, extra_metadata):
    harness = tmp_path / "h_add_err.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text("additional_bom_items:\n  - {type: Tape}\nconnections: []\n")
    meta.write_text("metadata: {title: t, pn: p, company: c, address: a}")

    def raise_type_error(self, item):
        raise TypeError("boom")

    monkeypatch.setattr(
        "filare.models.harness.Harness.add_additional_bom_item", raise_type_error
    )
    with pytest.raises(TypeError):
        build_harness_from_files(
            inp=[harness],
            metadata_files=[meta],
            return_types=("harness",),
            output_formats=(),
            output_dir=tmp_path,
            extra_metadata=extra_metadata,
        )


def test_return_types_include_png_svg(monkeypatch, tmp_path, extra_metadata):
    harness = tmp_path / "h_return.yml"
    meta = tmp_path / "meta.yml"
    harness.write_text(
        """\
connectors: {X1: {pincount: 1}}
cables: {C1: {wirecount: 1}}
connections:
  - - X1: [1]
    - C1: [1]
"""
    )
    meta.write_text("metadata: {title: t, pn: p, company: c, address: a}")

    # Avoid heavy graphviz by monkeypatching png/svg properties
    class DummyHarness:
        png = b"p"
        svg = "<svg/>"

    monkeypatch.setattr(
        "filare.models.harness.Harness.png", property(lambda self: DummyHarness.png)
    )
    monkeypatch.setattr(
        "filare.models.harness.Harness.svg", property(lambda self: DummyHarness.svg)
    )

    ret = build_harness_from_files(
        inp=[harness],
        metadata_files=[meta],
        return_types=("png", "svg"),
        output_formats=(),
        output_dir=tmp_path,
        extra_metadata=extra_metadata,
    )
    assert ret["png"] == b"p"
    assert ret["svg"] == "<svg/>"
